---
layout: post
title: "问题1——验证小字符串中的字母是否都在大字符串中"
category: 
tags: []
---
{% include JB/setup %}

从别人那转来的，网址在这。。。<a href="http://www.aqee.net/2011/04/11/google-interviewing-story/">一次谷歌面试趣事</a>

问题：

假设这有一个各种字母组成的字符串，假设这还有另外一个字符串，而且这个字符串里的字母数相对少一些。从算法是讲，什么方法能最快的查出所有小字符串里的字母在大字符串里都有？

比如，如果是下面两个字符串：

String 1:  ABCDEFGHLMNOPQRS

String 2:  DCGSRQPOM

答案是true，所有在string2里的字母string1也都有。如果是下面两个字符串：

String 1:  ABCDEFGHLMNOPQRS

String 2:  DCGSRQPOZ

答案是false，因为第二个字符串里的Z字母不在第一个字符串里。

4种做法：

1. 对于这种操作一种幼稚的做法是轮询第二个字符串里的每个字母，看它是否同在第一个字符串里。从算法上讲，这需要<code>O(n*m)</code>次操作，其中n是string1的长度，m是string2的长度。就拿上面的例子来说，最坏的情况下将会有16*8 = 128次操作。

2.一个稍微好一点的方案是先对这两个字符串的字母进行排序，然后同时对两个字串依次轮询。两个字串的排序需要(常规情况)<code>O(m log m) + O(n log n)</code>次操作，之后的线性扫描需要<code>O(m+n)</code>次操作。同样拿上面的字串做例子，将会需要16*4 + 8*3 = 88加上对两个字串线性扫描的16 + 8 = 24的操作。(随着字串长度的增长，你会发现这个算法的效果会越来越好)

3. 一个最佳的算法，只需要<code>O(n+m)</code>次操作。方法就是，对第一个字串进行轮询，把其中的每个字母都放入一个 Hashtable里(成本是O(n)或16次操作)。然后轮询第二个字串，在Hashtable里查询每个字母，看能否找到。如果找不到，说明没有匹配 成功。这将消耗掉8次操作 —— 这样两项操作加起来一共只有24次。

4. ”如果这样呢 —— 假设我们有一个一定个数的字母组成字串 ——  我给每个字母分配一个素数，从2开始，往后类推。这样A将会是2，B将会是3，C将会是5，等等。现在我遍历第一个字串，把每个字母代表的素数相乘。你最 终会得到一个很大的整数，对吧？然后 ——  轮询第二个字符串，用每个字母除它。如果除的结果有余数，这说明有不匹配的字母。如果整个过程中没有余数，你应该知道它是第一个字串恰好的子集了。