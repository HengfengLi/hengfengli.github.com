---
layout: post
title: "1 - Implement insertion and deletion on a trie"
categories: [programming]
tags: [algorithm]
published: true
---

今天电话面试遇到这样的一个题目。很遗憾，没有正确地写出来，还是基本功不够。第一次写trie，
基本的概念知道，但是要真正写起代码来了，自己还是差很远。需要好好反思一下，
自己为什么没写出来，具体的思路应该是怎么样的。

---

__Problem:__ Given a trie (prefix tree), implement insertion and deletion 
of a word. 

                        Root
            /             |            \
            A             I            T
            |          /    \      /   |    \
            #         N      S    A    H     O
                      |      |    |    |      \
                      #      #    V    E       W
                                  |    | \     |
                                  E    R  #    N
                                  |    |       |
                                  R    E       #
                                  |    |
                                  N    #
                                  |
                                  #

__Input__:

word: a string "[a-z]*". 

__Output__:

- insert(word)
- delete(word)

---

__Definition of a TrieNode (TreeNode):__ 

~~~ python
class TreeNode:
    def __init__(self, ch):
        self.val = ch
        self.children = [None]*27 # [0..25] are [a..z], [26] is for '#'.
~~~

<br />

__Insertion (recursive):__

1) If "", reach the end of target word, and insert '#' for representing 
that there is a word ending here. 

2) If not "", 

- 2.a) if child word[0] doesn't exist. Create a new one. 
- 2.b) Insert word[1:] to the word[0]'s subtree. 

<br />

__Deletion (recursive):__

1) What should be deleted? a node without any child (including '#'). 

2) Where to delete? Node's parent. A parent should get a return 
value to know whether or not it should delete that node. 

Check whether a node should be deleted. 

~~~ python
for child in root.children:
    if child != None:
        return False
return True
~~~

If target word is "", then clean '#'. So that there is not a word anymore. 

~~~ python
if not word:
    root.children[-1] = None
~~~

If target word is not empty, then decide whether we can delete child word[0].

~~~ python
ind = ord(word[0])-ord('a')
# the node exist, delete this node
if root.children[ind] and detele(root.children[ind], word[1:]):
    root.children[ind] = None
~~~

<br />

__Complete solution:__

~~~ python
class TreeNode:
    def __init__(self, ch):
        self.val = ch
        self.children = [None]*27
    
def insert(root, word):
    if not word:
        root.children[-1] = '#'
        return # easy to forget
    
    ind = ord(word[0])-ord('a')
    
    if not root.children[ind]:
        root.children[ind] = TreeNode(word[0])
    
    insert(root.children[ind], word[1:])

def detele(root, word):
    if not word:
        # We reach the end of target word:
        # e.g. "the" or "ther", to remove '#'. 
        root.children[-1] = None
    else:
        # not reach the end. 
        ind = ord(word[0])-ord('a')
        # the node exist, delete this node
        if root.children[ind] and detele(root.children[ind], word[1:]):
            root.children[ind] = None
    
    # answer whether or not this node can be removed. 
    for child in root.children:
        if child != None:
            return False
    return True


def get_all(root, word, all_words):
    
    if root.children[-1] == '#':
        all_words.append(word)
    
    for i in range(26):
        if root.children[i] != None:
            new_word = word + root.children[i].val
            get_all(root.children[i], new_word, all_words)
    
    
root = TreeNode(None)

insert(root, "a")
insert(root, "in")
insert(root, "is")
insert(root, "tavern")
insert(root, "the")
insert(root, "there")
insert(root, "town")

words = []
get_all(root, "", words)
print words

words = []
detele(root, "ie")
detele(root, "ther")
detele(root, "there")
get_all(root, "", words)
print words
~~~

Leetcode的
[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/)
和
[211. Add and Search Word - Data structure design](https://leetcode.com/problems/add-and-search-word-data-structure-design/)
是考察Trie的。

Algorithms 4th里面有一章（Chapter 5.2, page 730）专门讲Trie，可以好好复习一下。

面试是一个考察智力和心理的过程，遇到没见过的题目，该如何应对？
在时间和面试官看着你写代码的压力下，
是否能像平常一样思考问题？会不会在有人看你编程的时候，容易紧张？

通过大量的练习，养成良好的解决问题的方法，而不是单纯地去记答案。
自己想出来的solution，远比记忆他人的答案，更有效。
多练习，勤思考，才是唯一的解决方案。




